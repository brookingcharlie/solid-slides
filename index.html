<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Test-Driven Development and Principles of Software Design</title>

  <meta name="description" content="Hands-on test-driven development exercise illustrating principles for good software design">
  <meta name="author" content="Steve Morris and Charlie Brooking">
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/thoughtworks.css" id="theme">
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">
      <section class="title">
        <h1>Test-Driven Development</h1>
        <h3>and Principles of Software Design</h3>
      </section>

      <section>
        <h2>The exercise</h2>
        <div style="display: inline-block; width: 65%;">
          <h4>Shopping checkout</h4>
          <p>Take customer's shopping basket and generate an itemised receipt.</p>
          <p><em>We'll build a simple console application using TDD.</em></p>
        </div>
        <div style="display: inline-block; width: 25%;">
          <img class="no-border" style="width: 100%;" src="img/ic_shopping_basket_48px.svg">
        </div>
      </section>

      <section>
      <section>
        <h2>Task 1: Simple app</h2>
        <div style="display: inline-block; width: 35%; vertical-align: top;">
          <h4>Input</h4>
          <pre><code data-trim class="nohighlight">
Pizza - Pepperoni,12.99
Pizza - Supreme,12.99
Garlic bread,8.50
Chianti,21.00
          </code></pre>
        </div>
        <div style="display: inline-block; width: 55%; vertical-align: top;">
          <h4>Ouput</h4>
          <pre><code data-trim class="nohighlight">
*************** RECEIPT ****************

Pizza - Pepperoni                  12.99
Pizza - Supreme                    12.99
Garlic bread                        8.50
Chianti                            21.00
                                --------
Total for 4 items                  55.48
                                ========
          </code></pre>
        </div>
      </section>

      <section>
        <h2>Simple app test</h2>
        <pre style="font-size: 0.45em;"><code data-trim class="java">
@Test
public void testSingle() throws Exception {
    String input =
        "Pizza - Pepperoni,12.99";
    String expectedOutput =
        "*************** RECEIPT ****************\n" +
        "\n" +
        "Pizza - Pepperoni                  12.99\n" +
        "                                --------\n" +
        "Total for 1 items                  12.99\n" +
        "                                ========\n";
    try (
        StringReader reader = new StringReader(input);
        StringWriter writer = new StringWriter();
    ) {
        App.run(reader, writer);
        assertThat(writer.toString(), is(equalTo(expectedOutput)));
    }
}
        </code></pre>
      </section>

      <section>
        <h2>Simple app code</h2>
        <pre style="font-size: 0.45em;"><code data-trim class="java">
public static void run(Reader reader, Writer writer) throws IOException {
    try (
        BufferedReader bufferedReader = new BufferedReader(reader);
        PrintWriter printWriter = new PrintWriter(writer);
    ) {
        String line = bufferedReader.readLine();
        String[] parts = line.split(",");
        String product = parts[0];
        BigDecimal price = new BigDecimal(parts[1]);

        printWriter.println("*************** RECEIPT ****************");
        printWriter.println();
        printWriter.println(String.format("%-32s%8.2f", product, price));
        printWriter.println(String.format("%-32s%8s", "", "--------"));
        printWriter.println(String.format("%-32s%8.2f", "Total for 1 items", price));
        printWriter.println(String.format("%-32s%8s", "", "========"));
    }
}
        </code></pre>
      </section>
      </section>

      <section>
        <h2 style="font-size: 1.5em;">Single Responsibility Principle</h2>
        <blockquote>A class should have one, and only one, reason to change.</blockquote>
        <p>Responsibilities of our <code>App</code> class?</p>
        <ol>
          <li>Reads formatted input text</li>
          <li>Calculates total price (well, it will)</li>
          <li>Writes formatted output text</li>
        </ol>
        <!--
          readability
          testability: unit carrying out multiple tasks is difficult to test
          reusability
          
          example: mixing text parsing, query processing, and output
        -->
      </section>

      <section>
      <section>
        <h2>Task 2: App modules</h2>
        <p>Separate the <code>App</code> class's responsibilities:</p>
        <ol>
          <li>Model basket concept as domain class</li>
          <li>Make basket responsible for calculating total</li>
          <li>Read/write text formats in separate class</li>
        </ol>
        <pre><code data-trim class="java">
public class Basket {
    public void addItem(Item item) {...}
    public Item getItem(int i) {...}
    public int getCount() {...}
    public BigDecimal getTotal() {...}
}

public static void run(Reader input, Writer output) throws IOException {
    Basket basket = new Basket();
    new BasketReader().read(basket, input);
    new BasketWriter().write(basket, output);
}
        </code></pre>
      </section>

      <section>
        <h2>Basket test</h2>
        <p>Test adding/getting items, count, and total.</p>
        <pre><code data-trim class="java">
@Test
public void testSingleItem() {
    Basket basket = new Basket();
    basket.addItem(new Item("Pizza - Pepperoni", new BigDecimal("12.99")));
    assertThat(basket.getCount(), is(equalTo(1)));
    assertThat(basket.getItem(0).getProduct(),
        is(equalTo("Pizza - Pepperoni")));
    assertThat(basket.getItem(0).getPrice(),
        is(equalTo(new BigDecimal("12.99"))));
    assertThat(basket.getTotal(),
        is(equalTo(new BigDecimal("12.99"))));
}
        </code></pre>
      </section>

      <section>
        <h2>Basket code</h2>
        <pre><code data-trim class="java">
public class Basket {
    private final ArrayList&lt;Item&gt; items;

    public Basket() { this.items = new ArrayList&lt;Item&gt;(); }
    public void addItem(Item item) { items.add(item); }
    public Item getItem(int i) { return items.get(i); }
    public int getCount() { return items.size(); }

    public BigDecimal getTotal() {
        return items.stream()
            .map(i -&gt; i.getPrice())
            .reduce((a, b) -&gt; a.add(b))
            .orElse(new BigDecimal("0.00"));
    }
}
        </code></pre>
      </section>

      <section>
        <h2>Basket reader test</h2>
        <p>Verify that reader adds items to the basket.</p>
        <pre><code data-trim class="java">
@Test
public void testSingleItem() throws IOException {
    Basket basket = mock(Basket.class);
    StringReader input = new StringReader("Pizza - Pepperoni,12.99\n");
    new BasketReader().read(basket, input);

    ArgumentCaptor&lt;Item&gt; item = ArgumentCaptor.forClass(Item.class);
    verify(basket, times(1)).addItem(item.capture());
    assertThat(item.getValue().getProduct(),
        is(equalTo("Pizza - Pepperoni")));
    assertThat(item.getValue().getPrice(),
        is(equalTo(new BigDecimal("12.99"))));
}
        </code></pre>
      </section>

      <section>
        <h2>Basket reader code</h2>
        <pre><code data-trim class="java">
public void read(Basket basket, Reader input) throws IOException {
    try (
        BufferedReader bufferedReader = new BufferedReader(input);
    ) {
        bufferedReader.lines()
            .map(line -&gt; line.split(","))
            .map(parts -&gt; new Item(parts[0], new BigDecimal(parts[1])))
            .forEach(item -&gt; basket.addItem(item));
    }
}
        </code></pre>
      </section>

      <section>
        <h2>Basket writer test</h2>
        <p>Compare actual vs. expected output.</p>
        <pre><code data-trim class="java">
@Test
public void testSingleItem() throws IOException {
    Basket basket = new Basket();
    basket.addItem(new Item("Pizza - Pepperoni", new BigDecimal("12.99")));
    StringWriter output = new StringWriter();
    new BasketWriter().write(basket, output);

    String expectedOutput =
        "*************** RECEIPT ****************\n" +
        "\n" +
        "Pizza - Pepperoni                  12.99\n" +
        "                                --------\n" +
        "Total for 1 items                  12.99\n" +
        "                                ========\n";
    assertThat(output.toString(), is(equalTo(expectedOutput)));
}
        </code></pre>
      </section>

      <section>
        <h2>Basket writer code</h2>
        <pre style="font-size: 0.54em;"><code data-trim class="java">
public void write(AccessibleBasket basket, Writer output) throws IOException {
  try (PrintWriter printer = new PrintWriter(output)) {
    printer.println("*************** RECEIPT ****************");
    printer.println();
    for (int i = 0; i &lt; basket.getCount(); i++) {
      printer.println(String.format("%-32s%8.2f",
        basket.getItem(i).getProduct(), basket.getItem(i).getPrice()));
    }
    printer.println(String.format("%-32s%8s", "", "--------"));
    String total = String.format("Total for %d items", basket.getCount());
    printer.println(String.format("%-32s%8.2f", total, basket.getTotal()));
    printer.println(String.format("%-32s%8s", "", "========"));
  }
}
        </code></pre>
      </section>
      </section>

      <section>
        <h2 style="font-size: 1.40em;">Interface Segregation Principle</h2>
        <blockquote>Make fine grained interfaces that are client specific.</blockquote>
        <p>Consider the clients of our <code>Basket</code> class:</p>
        <ul>
          <li><code>BasketReader</code> only needs <code>addItem</code></li>
          <li><code>BasketWriter</code> needs getters (item, count, total)</code></li>
          <li>...but it shouldn't be able to call <code>addItem</code></li>
        </ul>
        <!--
          - Fat interface imposes implementation burden on author of class ahering to interface.
          - Fat interface is confusing for use of the class - which method do I call?
          - Fat interface could lead to user of class calling methods that it shouldn't.
        -->
      </section>

      <section>
      <section>
        <h2>Task 3: Segregate interfaces</h2>
        <pre style="font-size: 0.52em;"><code data-trim class="java">
public interface MutatableBasket {
    void addItem(Item item);
}
public interface AccessibleBasket {
    Item getItem(int i);
    int getCount();
    BigDecimal getTotal();
}
public class Basket implements MutatableBasket, AccessibleBasket {...}

public class BasketReader {
    public void read(MutatableBasket basket, Reader input) {...}
}
public class BasketWriter {
    public void write(AccessibleBasket basket, Writer output) {...}
}
        </code></pre>
      </section>
      </section>

      <section>
        <h2 style="font-size: 1.55em;">Liskov Substitution Principle</h2>
        <blockquote>
          Functions that reference base classes must be able to use
          their derived classes without knowing it.
        </blockquote>
        <div style="display: inline-block; width: 45%;">
          <pre style="font-size: 0.52em;"><code data-trim class="java">
abstract class Shape {
}
class Rectangle extends Shape {
  void drawRectangle() {...}
}
class Square extends Shape {
  void drawSquare() {...}
}
class App {
  void render(Shape s) {
    if (s instanceof Rectangle) {
      shape.drawRectangle();
    }
    // ...
  }
}
          </code></pre>
        </div>
        <div style="display: inline-block; width: 45%;">
          <pre style="font-size: 0.52em;"><code data-trim class="java">
abstract class Shape {
  abstract void draw();
}
class Rectangle extends Shape {
  void draw() {...}
}
class Square extends Shape {
  void draw() {...}
}


class App {
  void render(Shape shape) {
    shape.draw();
  }
}
          </code></pre>
        </div>
        <!--
          Derived classes must be substitutable for their base classes.

          http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
        -->
      </section>

      <section>
      <section>
        <h2>Task 4: Sale basket</h2>
        <blockquote>Everything must go!</blockquote>
        <ul>
          <li>Give all customers 10% discount</li>
          <li>Print discount message on receipt</li>
        </ul>
      </section>

      <section>
        <h2>A sale basket</h2>
        <pre><code data-trim class="java">
public class SaleBasket extends Basket {
  @Override
  public BigDecimal getTotal() {
    return super.getTotal().multiply(new BigDecimal("0.9")).setScale(2);
  }
}
        </code></pre>
        <pre><code class="diff">       String totalDescription = String.format("Total for %d items", basket.getCount());
       printWriter.println(String.format("%-32s%8.2f", totalDescription, basket.getTotal()));
       printWriter.println(String.format("%-32s%8s", "", "====...."));
+      if (basket instanceof SaleBasket) {
+        printWriter.println("Includes discount of 10%");
+      }
     }
   }</code></pre>
      </section>

      <section>
        <h2>Another sale basket</h2>
        <p><code>Basket</code> vs <code>SaleBasket</code></p>
        <pre><code data-trim class="diff">
+    public String getMessage() {
+        return null;
+    }
        </code></pre>
        <pre><code data-trim class="diff">
+    @Override
+    public String getMessage() {
+        return "Includes discount of 10%";
+    }
        </code></pre>
        <p><code>BasketWriter.java</code></p>
        <pre><code data-trim class="diff">
-    if (basket instanceof SaleBasket) {
-      printWriter.println("Includes discount of 10%");
-    }
+    if (basket.getMessage() != null) {
+      printWriter.println(basket.getMessage());
+    }
        </code></pre>
      </section>
      </section>

      <section>
        <h2>Open-Closed Principle</h2>
        <blockquote>Software entities should be open for extension, but closed for modification.</blockquote>
        <p><b>Problem:</b> cannot extend a class without modifying it.</p>
        <ul>
          <li>changes to a class result in...</li>
          <li>mass changes to dependent classes</li>
        </ul>
        <p><b>Solution:</b> design fixed classes with extension points.</p>
        <ul>
          <li>extend class behaviour by...</li>
          <li>adding code instead of modifying it</li>
        </ul>
        <!--
          "You should be able to extend a classes behavior without modifying it."

          "When a single change to a program results in a cascade of changes to dependent
          modules, that program exhibits the undesirable attributes that we have come to
          associate with “bad” design. The program becomes fragile, rigid, unpredictable
          and unreusable. The open- closed principle attacks this in a very straightforward
          way. It says that you should design modules that never change. When requirements
          change, you extend the behavior of such modules by adding new code, not by
          changing old code that already works."

          "Create abstractions that are fixed and yet represent an unbounded group of possible behaviors.
          A module depending on an abstraction can be fixed, yet the behavior of that module can be extended
          by creating new derivatives of the abstraction."

          ## Benefits

          - Application will be more robust because we are not changing already tested class.
          - Flexible because we can easily accommodate new requirements.
          - Easy to test and less error prone.

          ## Examples

          - Abstract factory pattern: create something whose type isn't known until runtime.
          - Template method pattern: set of steps is the same, but implementation of steps differs.
          - Decorator pattern: recursively extend behaviour via composition instead of inheritance.

          http://www.objectmentor.com/resources/articles/ocp.pdf
          http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
        -->
      </section>

      <section>
      <section>
        <h2>Task 5: Extensible basket</h2>
        <blockquote>The basket to end all baskets</blockquote>
        <ul>
          <li>What else could we want in a basket?</li>
          <li>Maybe the discount should be a line item.</li>
          <li>What if future baskets need extra line items?</li>
        </ul>
      </section>
      <section>
        <h2>Our extensible basket</h2>
        <p><code>Basket</code> vs <code>SaleBasket</code></p>
        <pre><code data-trim class="diff">
+  @Override
+  public List&lt;Item&gt; getExtraItems() {
+    return Collections.emptyList();
+  }
        </code></pre>
        <pre><code data-trim class="diff">
+  @Override
+  public List&lt;Item&gt; getExtraItems() {
+    BigDecimal discount = super.getTotal().multiply(new BigDecimal("-0.1")).setScale(2);
+    return asList(new Item("Discount", discount));
+  }
        </code></pre>
        <p><code>BasketWriter.java</code></p>
        <pre><code class="diff">       for (int i = 0; i &lt; basket.getCount(); i++) {
         printWriter.println(String.format("%-32s%8.2f", basket.getItem(i).getProduct(), basket.getItem(i).getPrice()));
       }
+      for (Item item : basket.getExtraItems()) {
+        printWriter.println(String.format("%-32s%8.2f", item.getProduct(), item.getPrice()));
+      }</code></pre>
      </section>
      <section>
        <h2>Our extensible basket</h2>
        <p><code>Basket</code> vs <code>SaleBasket</code></p>
        <pre><code data-trim class="java">
public interface Basket implements MutatableBasket, AccessibleBasket {
  public void addItem(Item item) {...}
  public Item getItem(int i) {...}
  public int getCount() {...}
  public BigDecimal getTotal() {...}
  public List&lt;Item&gt; getExtraItems() {...}
  public String getMessage() {...}
}
        </code></pre>
      </section>
      </section>

      <section>
        <h2 style="font-size: 1.45em;">Dependency Inversion Principle</h2>
        <blockquote>High-level modules should not depend upon low-level modules.</blockquote>
        <p>Both should depend upon abstractions!</p>
        <ul>
          <li>Code naturally depends on its dependencies, right?</li>
          <li>But is this wrong? Does our design become brittle?</li>
          <li>Rigorously apply Open-Closed and Liskov.</li>
        </ul>
        <!--
          This quote has a Steve-esque level of incredulation:

          "This predicament is absurd! It is the high level modules that ought to be forcing
          the low level modules to change. It is the high level modules that should take
          precendence over the lower level modules. High level modules simply should not
          depend upon low level modules in any way."

          http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
        -->
      </section>

      <section>
      <section>
        <h2>Injected dependencies</h2>
        <pre><code data-trim class="diff">
 public class App {
+  private final BasketReader inputReader;
+  private final BasketWriter outputWriter;
+
+  public App(BasketReader inputReader, BasketWriter outputWriter) {
+    this.inputReader = inputReader;
+    this.outputWriter = outputWriter;
+  }

-  public static void run(Reader input, Writer output) throws IOException {
+  public void run(Reader input, Writer output) throws IOException {
-    BasketReader inputReader = new BasketReader();
-    BasketWriter outputWriter = new BasketWriter();
     Basket basket = new Basket();
     inputReader.read(basket, input);
     outputWriter.write(basket, output);
        </code></pre>
      </section>
      <section>
        <h2>Injecting dependencies</h2>
        <pre><code data-trim class="diff">
--- a/src/test/java/com/thoughtworks/checkout/AppTest.java
+++ b/src/test/java/com/thoughtworks/checkout/AppTest.java
@@ -25,7 +25,8 @@ public class AppTest {
       StringReader reader = new StringReader(input);
       StringWriter writer = new StringWriter();
     ) {
-      App.run(reader, writer);
+      App app = new App(new BasketReader(), new BasketWriter());
+      app.run(reader, writer);
       assertThat(writer.toString(), is(equalTo(expectedOutput)));
     }
   }
        </code></pre>
      </section>
      </section>

      <section>
        <h2>The "SOLID" principles</h2>
        <table style="font-size: 0.8em;">
          <tr>
            <th>Single Responsibility</th>
            <td>A class should have one, and only one, reason to change.</td>
          </tr>
          <tr>
            <th>Open-Closed</th>
            <td>You should be able to extend a class's behavior without modifying it.</td>
          </tr>
          <tr>
            <th>Liskov Substitution</th>
            <td>Derived classes must be substitutable for their base classes.</td>
          </tr>
          <tr>
            <th>Interface Segregation</th>
            <td>Make fine grained interfaces that are client specific.</td>
          </tr>
          <tr>
            <th style="border-bottom: none;">Dependency Inversion</th>
            <td>Depend on abstractions, not on concretions.</td>
          </tr>
        </table>
        <!--
          SOLID is a mnemonic for Robert Martin’s principles of object-oriented design.

          "first five principles" named by Robert C. Martin in the early 2000s
          that stands for five basic principles of object-oriented programming and design.

          The principles, when applied together, intend to make it more likely that a
          programmer will create a system that is easy to maintain and extend over time.

          The principles of SOLID are guidelines that can be applied while working on
          software to remove code smells by causing the programmer to refactor the software's
          source code until it is both legible and extensible

          https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)

          http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

          http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf
        -->
      </section>

      <section>
        <h2>Why BigDecimal?</h2>
        <pre><code data-trim class="java">
public class DecimalTest {
  @Test
  public void testIncorrectDoubles() {
    double result = 0.1 + 0.2;
    assertThat(result, is(equalTo(0.30000000000000004)));
  }

  @Test
  public void testCorrectBigDecimal() {
    BigDecimal result = new BigDecimal("0.1").add(new BigDecimal("0.2"));
    assertThat(result, is(equalTo(new BigDecimal("0.3"))));
  }
}
        </code></pre>
      </section>

    </div>
  </div>
  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>
  <script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'slide', // none/fade/slide/convex/concave/zoom
      // Optional reveal.js plugins
      dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
      ]
    });
  </script>
</body>
</html>
